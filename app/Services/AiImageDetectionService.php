<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;

/**
 * Detects AI-generated images on crawled sites using local heuristics.
 *
 * Analyzes images via five weighted sub-scores:
 * - URL patterns (30%) — Known AI CDN domains and filename patterns
 * - Metadata (30%) — EXIF Software/UserComment, XMP creator, C2PA/JUMBF markers
 * - HTML context (20%) — Alt text, captions, surrounding text mentioning AI tools
 * - Resolution (10%) — AI-typical dimensions (512x512, 1024x1024, etc.)
 * - Format quirks (10%) — Missing camera EXIF, ICC profile analysis
 */
class AiImageDetectionService
{
    /** @var int Maximum number of images to analyze per page */
    private const MAX_IMAGES = 20;

    /** @var int Download timeout in seconds */
    private const DOWNLOAD_TIMEOUT = 5;

    /** @var int Maximum file size to download (10MB) */
    private const MAX_FILE_SIZE = 10 * 1024 * 1024;

    /** @var int Minimum confidence threshold for counting as AI image */
    private const CONFIDENCE_THRESHOLD = 40;

    /** Known AI image CDN domains */
    public const AI_CDN_DOMAINS = [
        'oaidalleapiprodscus.blob.core.windows.net',
        'dalleprodsec.blob.core.windows.net',
        'replicate.delivery',
        'cdn.midjourney.com',
        'cdn.discordapp.com',
        'images.openai.com',
        'stability-images.s3.amazonaws.com',
        'api.stability.ai',
        'cloud.leonardo.ai',
        'cdn.leonardo.ai',
        'storage.googleapis.com/imagen',
        'ideogram.ai',
        'fal.media',
        'together-ai-output.s3.amazonaws.com',
    ];

    /** Filename patterns suggesting AI generation */
    public const AI_FILENAME_PATTERNS = [
        '/dall[-_]?e/i',
        '/midjourney/i',
        '/stable[-_]?diffusion/i',
        '/sd[-_]xl/i',
        '/sdxl/i',
        '/\bflux\b/i',
        '/leonardo[-_]?ai/i',
        '/ideogram/i',
        '/img[-_]\d{8,}/i',
        '/generated[-_]image/i',
        '/ai[-_]generated/i',
        '/txt2img/i',
        '/img2img/i',
    ];

    /** AI tool keywords to look for in HTML context */
    public const AI_CONTEXT_KEYWORDS = [
        'ai generated', 'ai-generated', 'generated by ai',
        'dall-e', 'dall·e', 'dalle', 'midjourney', 'stable diffusion',
        'flux', 'leonardo ai', 'ideogram', 'firefly', 'adobe firefly',
        'created with ai', 'made with ai', 'ai art', 'ai image',
        'ai illustration', 'generated image', 'ai creation',
        'machine generated', 'synthetically generated',
        'text-to-image', 'text to image', 'imagen',
        'playground ai', 'nightcafe', 'artbreeder',
    ];

    /** EXIF Software field values indicating AI generation */
    public const AI_EXIF_SOFTWARE = [
        'dall-e', 'dalle', 'midjourney', 'stable diffusion',
        'automatic1111', 'comfyui', 'invoke ai', 'novelai',
        'leonardo.ai', 'ideogram', 'adobe firefly',
        'flux', 'playground', 'fooocus',
    ];

    /** AI-typical image dimensions (width x height) */
    public const AI_DIMENSIONS = [
        [512, 512], [768, 768], [1024, 1024], [1024, 1792], [1792, 1024],
        [512, 768], [768, 512], [512, 896], [896, 512],
        [1024, 576], [576, 1024], [1024, 768], [768, 1024],
        [1280, 720], [720, 1280], [1344, 768], [768, 1344],
        [1152, 896], [896, 1152],
    ];

    /**
     * Analyze HTML page for AI-generated images.
     *
     * @return array{ai_image_count: int, ai_image_score: int, ai_image_details: array<int, array{url: string, confidence: int, signals: list<string>, breakdown: array<string, int>}>}
     */
    public function analyze(string $html, string $baseUrl): array
    {
        $imageUrls = $this->extractImageUrls($html, $baseUrl);

        $details = [];

        foreach (array_slice($imageUrls, 0, self::MAX_IMAGES) as $imageInfo) {
            $result = $this->analyzeImage($imageInfo['url'], $imageInfo['context'], $html);

            if ($result['confidence'] > 0) {
                $details[] = $result;
            }
        }

        // Sort by confidence descending
        usort($details, fn (array $a, array $b) => $b['confidence'] <=> $a['confidence']);

        $aiImages = array_filter($details, fn (array $d) => $d['confidence'] >= self::CONFIDENCE_THRESHOLD);
        $maxConfidence = count($details) > 0 ? $details[0]['confidence'] : 0;

        return [
            'ai_image_count' => count($aiImages),
            'ai_image_score' => $maxConfidence,
            'ai_image_details' => array_values($details),
        ];
    }

    /**
     * Extract image URLs and their HTML context from the page.
     *
     * @return array<int, array{url: string, context: string}>
     */
    public function extractImageUrls(string $html, string $baseUrl): array
    {
        $images = [];

        // Match <img> tags
        if (preg_match_all('/<img\b[^>]*>/is', $html, $matches, PREG_OFFSET_CAPTURE)) {
            foreach ($matches[0] as [$tag, $offset]) {
                $src = $this->extractAttribute($tag, 'src')
                    ?? $this->extractAttribute($tag, 'data-src')
                    ?? $this->extractAttribute($tag, 'data-lazy-src');

                if (! $src) {
                    continue;
                }

                $url = $this->resolveUrl($src, $baseUrl);

                if (! $url) {
                    continue;
                }

                // Gather surrounding context (200 chars before and after)
                $contextStart = max(0, $offset - 200);
                $contextLength = strlen($tag) + 400;
                $context = substr($html, $contextStart, $contextLength);
                // Strip tags for text context analysis
                $context = strip_tags($context);

                // Also include alt text
                $alt = $this->extractAttribute($tag, 'alt') ?? '';
                $title = $this->extractAttribute($tag, 'title') ?? '';
                $context .= ' '.$alt.' '.$title;

                $images[] = [
                    'url' => $url,
                    'context' => $context,
                ];
            }
        }

        return $images;
    }

    /**
     * Analyze a single image for AI generation signals.
     *
     * @return array{url: string, confidence: int, signals: list<string>, breakdown: array<string, int>}
     */
    private function analyzeImage(string $url, string $context, string $html): array
    {
        $urlScore = $this->scoreUrlPatterns($url);
        $contextScore = $this->scoreHtmlContext($context);

        // Try to download and analyze the image file
        $metadataScore = 0;
        $resolutionScore = 0;
        $formatScore = 0;
        $fileSignals = [];

        $imageData = $this->downloadImage($url);

        if ($imageData !== null) {
            [$metadataScore, $metaSignals] = $this->scoreMetadata($imageData);
            [$resolutionScore, $resSignals] = $this->scoreResolution($imageData);
            [$formatScore, $fmtSignals] = $this->scoreFormatQuirks($imageData);
            $fileSignals = array_merge($metaSignals, $resSignals, $fmtSignals);
        }

        // Weighted composite score
        $confidence = (int) round(
            $urlScore['score'] * 0.30 +
            $metadataScore * 0.30 +
            $contextScore['score'] * 0.20 +
            $resolutionScore * 0.10 +
            $formatScore * 0.10
        );

        $confidence = max(0, min(100, $confidence));

        $signals = array_merge($urlScore['signals'], $contextScore['signals'], $fileSignals);

        return [
            'url' => $url,
            'confidence' => $confidence,
            'signals' => array_values(array_unique($signals)),
            'breakdown' => [
                'url_patterns' => $urlScore['score'],
                'metadata' => $metadataScore,
                'html_context' => $contextScore['score'],
                'resolution' => $resolutionScore,
                'format_quirks' => $formatScore,
            ],
        ];
    }

    /**
     * Score based on URL patterns and known AI CDN domains.
     *
     * @return array{score: int, signals: list<string>}
     */
    public function scoreUrlPatterns(string $url): array
    {
        $score = 0;
        $signals = [];
        $parsedUrl = parse_url($url);
        $host = $parsedUrl['host'] ?? '';
        $path = $parsedUrl['path'] ?? '';

        // Check against known AI CDN domains
        foreach (self::AI_CDN_DOMAINS as $domain) {
            if (str_contains($host, $domain) || $host === $domain) {
                $score = 100;
                $signals[] = "AI CDN domain: {$domain}";

                return ['score' => $score, 'signals' => $signals];
            }
        }

        // Check filename patterns
        $filename = basename($path);
        foreach (self::AI_FILENAME_PATTERNS as $pattern) {
            if (preg_match($pattern, $filename)) {
                $score = max($score, 70);
                $signals[] = "AI filename pattern: {$filename}";
            }
        }

        // Check full URL path for AI tool names
        $urlLower = strtolower($url);
        foreach (['dall-e', 'dalle', 'midjourney', 'stable-diffusion', 'stablediffusion'] as $tool) {
            if (str_contains($urlLower, $tool)) {
                $score = max($score, 80);
                $signals[] = "AI tool in URL: {$tool}";
            }
        }

        return ['score' => min(100, $score), 'signals' => $signals];
    }

    /**
     * Score based on HTML context around the image.
     *
     * @return array{score: int, signals: list<string>}
     */
    public function scoreHtmlContext(string $context): array
    {
        $score = 0;
        $signals = [];
        $contextLower = strtolower($context);

        foreach (self::AI_CONTEXT_KEYWORDS as $keyword) {
            if (str_contains($contextLower, $keyword)) {
                $score += 25;
                $signals[] = "Context keyword: {$keyword}";
            }
        }

        return ['score' => min(100, $score), 'signals' => $signals];
    }

    /**
     * Score EXIF/XMP metadata for AI generation markers.
     *
     * @return array{0: int, 1: list<string>}
     */
    public function scoreMetadata(string $imageData): array
    {
        $score = 0;
        $signals = [];

        // Check for C2PA/JUMBF markers (Content Credentials)
        if (str_contains($imageData, 'c2pa') || str_contains($imageData, 'jumb') || str_contains($imageData, 'JUMBF')) {
            $score += 40;
            $signals[] = 'C2PA/JUMBF content credentials detected';
        }

        // Check for AI tool XMP metadata
        $xmpMarkers = [
            'AI_Tool' => 'XMP AI tool tag',
            'xmp:CreatorTool' => 'XMP creator tool',
            'dc:description' => 'XMP description',
        ];

        foreach ($xmpMarkers as $marker => $label) {
            if (str_contains($imageData, $marker)) {
                foreach (self::AI_EXIF_SOFTWARE as $software) {
                    if (stripos($imageData, $software) !== false) {
                        $score += 50;
                        $signals[] = "{$label}: {$software}";
                    }
                }
            }
        }

        // Try EXIF extraction if available
        $tempFile = $this->writeTempFile($imageData);

        if ($tempFile !== null) {
            try {
                $exif = @exif_read_data($tempFile);

                if ($exif !== false) {
                    $software = strtolower($exif['Software'] ?? '');
                    $comment = strtolower($exif['UserComment'] ?? '');

                    foreach (self::AI_EXIF_SOFTWARE as $aiSoftware) {
                        if (str_contains($software, $aiSoftware)) {
                            $score += 60;
                            $signals[] = "EXIF Software: {$aiSoftware}";
                        }
                        if (str_contains($comment, $aiSoftware)) {
                            $score += 40;
                            $signals[] = "EXIF UserComment: {$aiSoftware}";
                        }
                    }
                }
            } catch (\Throwable) {
                // EXIF reading failed, continue
            } finally {
                @unlink($tempFile);
            }
        }

        return [min(100, $score), $signals];
    }

    /**
     * Score based on AI-typical image dimensions.
     *
     * @return array{0: int, 1: list<string>}
     */
    public function scoreResolution(string $imageData): array
    {
        $tempFile = $this->writeTempFile($imageData);

        if ($tempFile === null) {
            return [0, []];
        }

        try {
            $size = @getimagesize($tempFile);

            if ($size === false) {
                return [0, []];
            }

            $width = $size[0];
            $height = $size[1];

            foreach (self::AI_DIMENSIONS as [$aiW, $aiH]) {
                if ($width === $aiW && $height === $aiH) {
                    return [100, ["AI-typical resolution: {$width}x{$height}"]];
                }
            }

            // Check for square aspect ratio (common in AI images)
            if ($width === $height && $width >= 512) {
                return [50, ["Square aspect ratio: {$width}x{$height}"]];
            }

            return [0, []];
        } finally {
            @unlink($tempFile);
        }
    }

    /**
     * Score based on format quirks (missing camera EXIF, ICC profiles).
     *
     * @return array{0: int, 1: list<string>}
     */
    public function scoreFormatQuirks(string $imageData): array
    {
        $score = 0;
        $signals = [];

        $tempFile = $this->writeTempFile($imageData);

        if ($tempFile === null) {
            return [0, []];
        }

        try {
            // Check for missing camera EXIF (AI images typically lack camera data)
            $exif = @exif_read_data($tempFile);

            if ($exif !== false) {
                $hasCameraData = isset($exif['Make']) || isset($exif['Model']) || isset($exif['ExposureTime']);

                if (! $hasCameraData && isset($exif['Software'])) {
                    $score += 40;
                    $signals[] = 'Has Software tag but no camera data';
                }
            } elseif ($this->isJpeg($imageData)) {
                // JPEG with no EXIF at all is suspicious
                $score += 30;
                $signals[] = 'JPEG with no EXIF data';
            }

            // Check ICC profile using Imagick if available
            if (extension_loaded('imagick')) {
                try {
                    $imagick = new \Imagick;
                    $imagick->readImageBlob($imageData);
                    $profiles = $imagick->getImageProfiles('icc', false);
                    $imagick->clear();
                    $imagick->destroy();

                    if (empty($profiles)) {
                        $score += 20;
                        $signals[] = 'No ICC profile (Imagick)';
                    }
                } catch (\Throwable) {
                    // Imagick failed, skip
                }
            }

            return [min(100, $score), $signals];
        } finally {
            @unlink($tempFile);
        }
    }

    /**
     * Download an image with size and timeout limits.
     */
    private function downloadImage(string $url): ?string
    {
        try {
            $response = Http::timeout(self::DOWNLOAD_TIMEOUT)
                ->withOptions([
                    'stream' => true,
                    'headers' => [
                        'Accept' => 'image/*',
                    ],
                ])
                ->get($url);

            if (! $response->successful()) {
                return null;
            }

            $body = $response->body();

            if (strlen($body) > self::MAX_FILE_SIZE) {
                return null;
            }

            return $body;
        } catch (\Throwable $e) {
            Log::debug("Failed to download image: {$url}", ['error' => $e->getMessage()]);

            return null;
        }
    }

    /**
     * Extract an HTML attribute value from a tag string.
     */
    private function extractAttribute(string $tag, string $attribute): ?string
    {
        if (preg_match('/\b'.preg_quote($attribute, '/').'=["\']([^"\']*)["\']/', $tag, $m)) {
            return $m[1];
        }

        if (preg_match('/\b'.preg_quote($attribute, '/').'=(\S+)/', $tag, $m)) {
            return rtrim($m[1], '>');
        }

        return null;
    }

    /**
     * Resolve a potentially relative URL against a base URL.
     */
    private function resolveUrl(string $src, string $baseUrl): ?string
    {
        // Skip data URIs, empty srcs, and Next.js image proxy URLs
        if ($src === '' || str_starts_with($src, 'data:') || str_contains($src, '/_next/image')) {
            return null;
        }

        // Already absolute
        if (preg_match('/^https?:\/\//i', $src)) {
            return $src;
        }

        // Protocol-relative
        if (str_starts_with($src, '//')) {
            return 'https:'.$src;
        }

        // Relative URL
        $parsed = parse_url($baseUrl);
        $scheme = $parsed['scheme'] ?? 'https';
        $host = $parsed['host'] ?? '';

        if ($host === '') {
            return null;
        }

        if (str_starts_with($src, '/')) {
            return "{$scheme}://{$host}{$src}";
        }

        $basePath = dirname($parsed['path'] ?? '/');

        return "{$scheme}://{$host}{$basePath}/{$src}";
    }

    /**
     * Write image data to a temporary file for analysis.
     */
    private function writeTempFile(string $data): ?string
    {
        $tempFile = tempnam(sys_get_temp_dir(), 'maim_img_');

        if ($tempFile === false) {
            return null;
        }

        file_put_contents($tempFile, $data);

        return $tempFile;
    }

    /**
     * Check if image data appears to be a JPEG.
     */
    private function isJpeg(string $data): bool
    {
        return strlen($data) >= 2 && ord($data[0]) === 0xFF && ord($data[1]) === 0xD8;
    }
}
